<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Python</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <header>
    <nav>
      <a href="https://docs.python.org/3/" target="_blank" rel="noopener noreferrer">Python</a>

      <input type="checkbox" id="menu-toggle">
      <label for="menu-toggle" class="menu-btn">☰</label>
      <ul>
        <li><a href="#zen">ZEN</a></li>
        <li><a href="#conversation">Steep Learning Curve</a></li>
        <li><a href="#oop">OOP</a></li>
        <li><a href="#algorithms">Algorithms</a></li>
        <li><a href="#letsuseit">Let's use it</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <section class="hero">
      <h1>WELCOME TO PYTHON</h1>
    </section>

    <section class="zen" id="zen">
      <h2>ZEN Of Python</h2>
      <p>If you wanna know about the core of Python, write in a new file of python <i>import this</i></p>
      <p>When you excecute this library you can view the rules to became python a language special. You can view this
        below:</p>

      <pre><code>The Zen of Python, by Tim Peters
1.Beautiful is better than ugly.
2.Explicit is better than implicit.
3.Simple is better than complex.
4.Complex is better than complicated.
5.Flat is better than nested.
6.Sparse is better than dense.
7.Readability counts.
8.Special cases aren't special enough to break the rules.
9.Although practicality beats purity.
10.Errors should never pass silently.
11.Unless explicitly silenced.
12.In the face of ambiguity, refuse the temptation to guess.
13.There should be one-- and preferably only one --obvious way to do it.
14.Although that way may not be obvious at first unless you're Dutch.
15.Now is better than never.
16.Although never is often better than *right* now.
17.If the implementation is hard to explain, it's a bad idea.
18.If the implementation is easy to explain, it may be a good idea.
19.Namespaces are one honking great idea -- let's do more of those!.
</code></pre>
    </section>

    <section class="basics" id="conversation">
      <h2>Python Basics — A Friendly Conversation</h2>

      <p><strong>Alex:</strong> Hey man, I just opened Python... what’s the first thing I should know?</p>

      <p><strong>Jordan:</strong> Easy. Think of variables as boxes. You put stuff inside them. Numbers, text, whatever.
      </p>

      <pre><code>name = "Alex"        # This is a string
age = 22             # This is number integer
is_cool = True       # This is a boolean
</code></pre>

      <p><strong>Alex:</strong> Oh, like labeling containers in my house?</p>
      <p><strong>Jordan:</strong> Exactly. Your brain got it before I finished the sentence.</p>

      <h3>Control Structures</h3>

      <p><strong>Alex:</strong> And how do I tell Python to make decisions?</p>

      <p><strong>Jordan:</strong> Same way you decide every day:</p>

      <pre><code>if age > 18:
    print("Welcome, adult!")
else:
    print("Sorry, kiddo!")
</code></pre>

      <h3>Data Structures</h3>

      <p><strong>Jordan:</strong> Now imagine you want to store multiple things.
        Lists are like backpacks. <strong>Dictionaries</strong> are like labeled drawers.</p>

      <pre><code>backpack = ["water", "notebook", "pencil"]
drawer = {"name": "Alex", "age": 22}
</code></pre>

      <h3>Working with Numbers</h3>

      <p><strong>Alex:</strong> So, what about numbers in Python? Are they complicated?</p>

      <p><strong>Jordan:</strong> Not at all. Python handles numbers like a pro.
        You’ve got three main types: integers, floats and complex numbers.
        But honestly, 99% of the time you'll use the first two.</p>

      <pre><code>age = 25            # integer
height = 1.82       # float
result = age + 10   # simple math
</code></pre>

      <p><strong>Alex:</strong> And Python understands math just like me?</p>
      <p><strong>Jordan:</strong> Hopefully better than you on a Monday morning.</p>

      <h3>While Loops</h3>

      <p><strong>Alex:</strong> I’ve heard about loops… like repeating stuff?</p>

      <p><strong>Jordan:</strong> Exactly. A <strong>while</strong> loop repeats as long as a condition is true.
        It’s like checking your phone every minute waiting for a message.</p>

      <pre><code>count = 0
while count < 3:
    print("Waiting...")
    count += 1
</code></pre>

      <p><strong>Alex:</strong> So it stops when <strong>count</strong> reaches 3?</p>
      <p><strong>Jordan:</strong> Yep. When the condition becomes false, the loop ends.</p>

      <h3>For Loops (Searching for something)</h3>

      <p><strong>Alex:</strong> And the <strong>for</strong> loop?</p>

      <p><strong>Jordan:</strong> The <strong>for</strong> loop is perfect for going through lists, strings, or any
        group of items.</p>

      <p><strong>Alex:</strong> Can you give me a real example?</p>

      <p><strong>Jordan:</strong> Sure. Let’s say you want to check if a list of products contains something.
        Even partial matches. Super useful in real life.</p>

      <pre><code>products = ["apple", "banana", "pineapple", "grape"]
search = "app"
found = []

for item in products:
    if search.lower() in item.lower():
        found.append(item)

if found:
    print("Matches found:", found)
else:
    print("No matches found.")
</code></pre>

      <p><strong>Alex:</strong> Wait… so if I search “app”, it finds “apple” AND “pineapple”?</p>

      <p><strong>Jordan:</strong> Exactly. That’s partial matching.
        Python checks if the word <strong>app</strong> exists inside each product name.</p>

      <p><strong>Alex:</strong> Damn, that’s actually useful.</p>

      <p><strong>Jordan:</strong> Welcome to Python, buddy.</p>

    </section>

    <section class="oop" id="oop">
      <h2>Object-Oriented Programming (OOP)</h2>

      <p><strong>Alex:</strong> Dude… everyone keeps saying “you need to learn <strong>OOP</strong>”.
        Why? What’s the big deal?</p>

      <p><strong>Jordan:</strong> Relax man. <strong>OOP</strong> is just a way to organize your code like real life.
        Think about your daily stuff — your phone, your backpack, your cat.
        Each one is an object with things it “has” and things it “does”.</p>

      <p><strong>Alex:</strong> So Python tries to copy that?</p>

      <p><strong>Jordan:</strong> Exactly. In Python you create your own objects using <strong>classes</strong>.
        Let me show you something simple…</p>

      <h3>A Basic Class</h3>

      <pre><code>class Player:
    def __init__(self, name, health):
        self.name = name
        self.health = health

    def greet(self):
        print(f"Hey, I'm {self.name}!")

player = Player("Alex", 100)
player.greet()
</code></pre>

      <p><strong>Alex:</strong> Ohh, so <strong>__init__</strong> is like the birth moment of the object?</p>

      <p><strong>Jordan:</strong> Yup. Baby Player is born with a name and health.</p>

      <h3>Adding Behavior <strong>(Methods)</strong></h3>

      <p><strong>Jordan:</strong> Let’s give the player an action.
        Like taking damage — everyday stuff, right?</p>

      <pre><code>class Player:
    def __init__(self, name, health):
        self.name = name
        self.health = health

    def take_damage(self, amount):
        self.health -= amount
        print(f"{self.name} took {amount} damage! Health is now {self.health}.")
</code></pre>

      <p><strong>Alex:</strong> Nice, now it feels like a game character.</p>

      <h3>Now let’s add a Simple <strong>Algorithm</strong></h3>

      <p><strong>Alex:</strong> And… <strong>algorithms</strong>? Can we mix one in there?</p>

      <p><strong>Jordan:</strong> Sure. Let’s say the player has an inventory and
        we want to check if an item exists. That's just a simple search <strong>algorithm</strong>.</p>

      <pre><code>class Player:
    def __init__(self, name):
        self.name = name
        self.inventory = ["sword", "shield", "apple", "potion"]

    def has_item(self, item):
        # Simple search algorithm (linear search)
        for obj in self.inventory:
            if obj == item:
                return True
        return False

player = Player("Alex")

print(player.has_item("apple"))   # True
print(player.has_item("banana"))  # False (sad fruit noises)
</code></pre>

      <p><strong>Alex:</strong> So that loop checking items one by one… that’s an <strong>algorithm</strong>?</p>

      <p><strong>Jordan:</strong> Yep. The simplest one.
        Also, 80% of beginners' LeetCode solutions start exactly like this.</p>

      <p><strong>Alex:</strong> Bro… I feel powerful.</p>

      <p><strong>Jordan:</strong> Congratulations, you now officially understand <strong>OOP and Algorithms</strong>.
        Your ancestors are proud.</p>

    </section>

    <section class="algorithms" id="algorithms">
      <h2>Algorithms</h2>

      <h3>Sliding Window</h3>

      <p><strong>Jordan:</strong> Alright Alex, this is one of the most important patterns in interviews.</p>

      <p><strong>Alex:</strong> Sliding window? Sounds… fancy.</p>

      <p><strong>Jordan:</strong> It’s not. It’s just a smarter way to loop.
        Instead of recalculating everything again and again,
        you <strong>slide</strong> a window across the data.</p>

      <p><strong>When to use it:</strong></p>
      <ul>
        <li>Subarrays or substrings</li>
        <li>Continuous ranges</li>
        <li>“Longest”, “shortest”, or “maximum” problems</li>
      </ul>

      <h3>Naive Approach (What NOT to do)</h3>

      <pre><code>numbers = [2, 1, 5, 1, 3, 2]
    k = 3
    max_sum = 0

    for i in range(len(numbers) - k + 1):
        current_sum = 0
        for j in range(i, i + k):
            current_sum += numbers[j]
        max_sum = max(max_sum, current_sum)

    print(max_sum)
    </code></pre>

      <p><strong>Jordan:</strong> This works, but it’s slow.
        Two loops = unnecessary pain.</p>

      <h3>Sliding Window Approach</h3>

      <pre><code>numbers = [2, 1, 5, 1, 3, 2]
    k = 3
    window_sum = 0
    max_sum = 0

    for i in range(len(numbers)):
        window_sum += numbers[i]

        if i >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= numbers[i - (k - 1)]

    print(max_sum)
    </code></pre>

      <p><strong>Alex:</strong> Ohhh… we don’t start over each time.</p>

      <p><strong>Jordan:</strong> Exactly.
        Add one element, remove one element.
        That’s the window sliding.</p>

      <h3>Why Interviewers Love This</h3>

      <ul>
        <li>Turns O(N²) into O(N)</li>
        <li>Shows optimization thinking</li>
        <li>Applies to dozens of problems</li>
      </ul>

      <p><strong>Jordan:</strong> Master this pattern,
        and half of LeetCode suddenly stops looking scary.</p>

    <h3>Two Pointers</h3>

    <p><strong>Alex:</strong> What about this “two pointers” thing?</p>

    <p><strong>Jordan:</strong> Simple idea: instead of using one index,
      you use <strong>two</strong> — usually one at the start and one at the end.</p>

    <p><strong>When to use it:</strong></p>
    <ul>
      <li>Sorted arrays</li>
      <li>Pairs that meet a condition</li>
      <li>Comparing values from both ends</li>
    </ul>

    <h3>Example: Pair with Target Sum</h3>

    <pre><code>numbers = [1, 2, 3, 4, 6]
        target = 6

        left = 0
        right = len(numbers) - 1

        while left < right:
            current_sum = numbers[left] + numbers[right]

            if current_sum == target:
                print(left, right)
                break
            elif current_sum < target:
                left += 1
            else:
                right -= 1
        </code></pre>

    <p><strong>Alex:</strong> So we move the pointers instead of looping twice?</p>

    <p><strong>Jordan:</strong> Exactly.
      One pass. Clean. Efficient.</p>

      <h3>Fast & Slow Pointers</h3>

      <p><strong>Alex:</strong> Why would I ever use two pointers moving at different speeds?</p>

      <p><strong>Jordan:</strong> To detect cycles.
        This pattern is famous for linked lists.</p>

      <p><strong>When to use it:</strong></p>
      <ul>
        <li>Cycle detection</li>
        <li>Linked lists</li>
        <li>Finding middle elements</li>
      </ul>

      <h3>Example: Detect a Cycle</h3>

      <pre><code>def has_cycle(head):
          slow = head
          fast = head

          while fast and fast.next:
              slow = slow.next
              fast = fast.next.next

              if slow == fast:
                  return True

          return False
      </code></pre>

      <p><strong>Alex:</strong> So if fast catches slow… boom?</p>

      <p><strong>Jordan:</strong> Cycle detected.
        Classic interview trick.</p>

      <h3>Binary Search</h3>

      <p><strong>Alex:</strong> Everyone talks about binary search. Why is it so important?</p>

      <p><strong>Jordan:</strong> Because it turns searching from slow to insanely fast —
        but only if the data is <strong>sorted</strong>.</p>

      <p><strong>When to use it:</strong></p>
      <ul>
        <li>Sorted arrays</li>
        <li>Search problems</li>
        <li>Optimization questions</li>
      </ul>

      <h3>Classic Binary Search</h3>

      <pre><code>numbers = [1, 3, 5, 7, 9, 11]
      target = 7

      left = 0
      right = len(numbers) - 1

      while left <= right:
          mid = (left + right) // 2

          if numbers[mid] == target:
              print(mid)
              break
          elif numbers[mid] < target:
              left = mid + 1
          else:
              right = mid - 1
      </code></pre>

      <p><strong>Alex:</strong> So we cut the search space in half every time?</p>

      <p><strong>Jordan:</strong> Exactly.
        That’s why it’s O(log N).</p>

        <h3>Prefix Sum</h3>

        <p><strong>Alex:</strong> Prefix sum sounds… mathematical.</p>

        <p><strong>Jordan:</strong> It’s just cumulative sums.
          Pre-calculate once, answer queries fast.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Range sum queries</li>
          <li>Subarray problems</li>
          <li>Optimization tasks</li>
        </ul>

        <h3>Building a Prefix Sum Array</h3>

        <pre><code>numbers = [2, 4, 6, 8, 10]
        prefix = [0]

        for num in numbers:
            prefix.append(prefix[-1] + num)

        # Sum from index 1 to 3
        result = prefix[4] - prefix[1]
        print(result)
        </code></pre>

        <p><strong>Alex:</strong> So we trade memory for speed?</p>

        <p><strong>Jordan:</strong> Exactly.
          That’s algorithmic thinking.</p>

        <h3>Hash Map (Frequency Counter)</h3>

        <p><strong>Alex:</strong> I keep seeing hash maps everywhere. Why are they so important?</p>

        <p><strong>Jordan:</strong> Because they let you store and access data in constant time.
          Perfect for counting and tracking things.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Counting frequencies</li>
          <li>Checking duplicates</li>
          <li>Fast lookups</li>
        </ul>

        <pre><code>text = "algorithm"
        frequency = {}

        for char in text:
            frequency[char] = frequency.get(char, 0) + 1

        print(frequency)
        </code></pre>

        <p><strong>Alex:</strong> So it’s like a super-fast dictionary?</p>

        <p><strong>Jordan:</strong> Exactly. Python makes this one feel unfair.</p>

        <h3>Stack</h3>

        <p><strong>Alex:</strong> Stack sounds like something piled up.</p>

        <p><strong>Jordan:</strong> That’s literally what it is.
          Last In, First Out — like browser history.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Undo / redo</li>
          <li>Parentheses validation</li>
          <li>Depth-first problems</li>
        </ul>

        <pre><code>stack = []
        expression = "()()"

        for char in expression:
            if char == "(":
                stack.append(char)
            else:
                if not stack:
                    print("Invalid")
                    break
                stack.pop()

        if not stack:
            print("Valid")
        </code></pre>

        <p><strong>Alex:</strong> Last in, first out… makes sense.</p>

        <p><strong>Jordan:</strong> Simple, but powerful.</p>

        <h3>Monotonic Stack</h3>

        <p><strong>Alex:</strong> Okay… what’s with this scary name?</p>

        <p><strong>Jordan:</strong> Relax. It’s just a stack that keeps elements
          in increasing or decreasing order.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Next greater element</li>
          <li>Previous smaller element</li>
          <li>Temperature / stock problems</li>
        </ul>

        <pre><code>temperatures = [73, 74, 75, 71, 69, 72]
        stack = []

        for i in range(len(temperatures)):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                prev = stack.pop()
                print(f"Day {prev} -> warmer at day {i}")
            stack.append(i)
        </code></pre>

        <p><strong>Alex:</strong> Oh… so we’re removing useless values?</p>

        <p><strong>Jordan:</strong> Exactly. That’s the trick.</p>

        <h3>Heap (Priority Queue)</h3>

        <p><strong>Alex:</strong> When would I use a heap?</p>

        <p><strong>Jordan:</strong> Whenever you need the smallest or largest element —
          fast.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Top K problems</li>
          <li>Scheduling</li>
          <li>Streaming data</li>
        </ul>

        <pre><code>import heapq

        numbers = [5, 1, 8, 3, 2]
        heapq.heapify(numbers)

        print(heapq.heappop(numbers))  # smallest
        print(heapq.heappop(numbers))
        </code></pre>

        <p><strong>Alex:</strong> So it’s not fully sorted, just organized?</p>

        <p><strong>Jordan:</strong> Exactly. Fast access, not full order.</p>

        <h3>Depth First Search (DFS)</h3>

        <p><strong>Alex:</strong> DFS sounds like exploring deep first.</p>

        <p><strong>Jordan:</strong> That’s exactly it.
          You go as far as possible before backing up.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Trees</li>
          <li>Graphs</li>
          <li>Backtracking problems</li>
        </ul>

        <pre><code>graph = {
            "A": ["B", "C"],
            "B": ["D"],
            "C": [],
            "D": []
        }

        def dfs(node):
            print(node)
            for neighbor in graph[node]:
                dfs(neighbor)

        dfs("A")
        </code></pre>

        <p><strong>Alex:</strong> Recursive by nature?</p>

        <p><strong>Jordan:</strong> Almost always.</p>

        <h3>Breadth First Search (BFS)</h3>

        <p><strong>Alex:</strong> So BFS is the opposite?</p>

        <p><strong>Jordan:</strong> Yep.
          You explore level by level.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Shortest path</li>
          <li>Level order traversal</li>
          <li>Graphs</li>
        </ul>

        <pre><code>from collections import deque

        queue = deque(["A"])
        visited = set()

        while queue:
            node = queue.popleft()
            if node not in visited:
                print(node)
                visited.add(node)
                queue.extend(graph[node])
        </code></pre>

        <p><strong>Alex:</strong> This one feels more controlled.</p>

        <p><strong>Jordan:</strong> And that’s why it finds shortest paths.</p>

        <h3>Backtracking</h3>

        <p><strong>Alex:</strong> This one sounds painful.</p>

        <p><strong>Jordan:</strong> It’s just trial and error —
          but organized.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Permutations</li>
          <li>Combinations</li>
          <li>Puzzles</li>
        </ul>

        <pre><code>def backtrack(path):
            if len(path) == 3:
                print(path)
                return

            for i in range(1, 4):
                if i not in path:
                    backtrack(path + [i])

        backtrack([])
        </code></pre>

        <p><strong>Alex:</strong> Try, fail, undo, repeat.</p>

        <p><strong>Jordan:</strong> Exactly. That’s backtracking.</p>

        <h3>Dynamic Programming (DP)</h3>

        <p><strong>Alex:</strong> Everyone says DP is hard.</p>

        <p><strong>Jordan:</strong> Only if you skip the basics.
          It’s just caching results.</p>

        <p><strong>When to use it:</strong></p>
        <ul>
          <li>Overlapping subproblems</li>
          <li>Optimization problems</li>
        </ul>

        <pre><code>memo = {}

        def fib(n):
            if n <= 1:
                return n
            if n not in memo:
                memo[n] = fib(n - 1) + fib(n - 2)
            return memo[n]

        print(fib(10))
        </code></pre>

        <p><strong>Alex:</strong> So DP is recursion + memory?</p>

        <p><strong>Jordan:</strong> That’s the secret.</p>
    </section>

    <section class="letsuseit" id="letsuseit">
      <h2>Let's Use It — <a href="https://github.com/Junkdog-04/python/tree/master/python-algorithms" target="_blank" rel="noopener noreferrer">A Real World Example</a></h2>

      <p><strong>Alex:</strong> Okay… we learned a ton of algorithms.
        But when do we actually use all of this together?</p>

      <p><strong>Jordan:</strong> Right now.
        Let’s simulate something real — an airport system.</p>

      <p><strong>Jordan:</strong> We’ll combine
        <strong>OOP</strong>, <strong>queues</strong>,
        <strong>two pointers</strong>, <strong>sliding window</strong>,
        <strong>binary search</strong>, <strong>BFS</strong> and <strong>DFS</strong>
        in one flow.
      </p>

      <h3>The Entry Point — main.py</h3>

      <p><strong>Jordan:</strong> Every Python program starts somewhere.
        This is our control tower.</p>

      <pre><code>def main():
        # Create the airport
        airport = Airport("Mexico City International")

        # Create a flight
        flight = Flight("MX203", "Buenos Aires", "15:30", "boarding")
        airport.add_flight(flight)
    </code></pre>

      <p><strong>Alex:</strong> So the airport manages flights and passengers?</p>

      <p><strong>Jordan:</strong> Exactly. That’s OOP doing its job.</p>

      <h3>Passengers Arrive — Queue in Action</h3>

      <pre><code>passengers = [
        Customer("Luis", seat_preference="window"),
        Customer("Ana", seat_preference="aisle", heavy_bag=True),
        Customer("Pedro", has_passport=False)
    ]

    for p in passengers:
        airport.enqueue_passenger(p)
    </code></pre>

      <p><strong>Alex:</strong> That’s a queue, right?</p>

      <p><strong>Jordan:</strong> Yep.
        First passenger in, first passenger processed.
        Just like real life.</p>

      <h3>Processing Passengers</h3>

      <pre><code>while True:
        passenger = airport.dequeue_passenger()
        if passenger is None:
            break
    </code></pre>

      <p><strong>Jordan:</strong> This loop keeps running until the queue is empty.</p>

      <p><strong>Alex:</strong> No passengers left — simulation ends.</p>

      <h3>Security Check — Simple Rules</h3>

      <pre><code>sec = airport.security_check(passenger)
    print("Security:", sec)

    if "Cleared" not in sec:
        continue
    </code></pre>

      <p><strong>Jordan:</strong> This is pure business logic.
        No algorithms yet — just conditions.</p>

      <p><strong>Alex:</strong> Passport missing?
        You’re not flying.</p>

      <h3>Seat Assignment — Two Pointers</h3>

      <pre><code>seat_msg = flight.assign_seat(passenger)
    print("Seat:", seat_msg)
    </code></pre>

      <p><strong>Jordan:</strong> Inside this method, we use
        <strong>Two Pointers</strong>.
      </p>

      <p><strong>Alex:</strong> One pointer from the front,
        one from the back… searching fast.</p>

      <h3>Sliding Window — Group Seats</h3>

      <p><strong>Jordan:</strong> If we needed seats together,
        we’d use a <strong>Sliding Window</strong>
        to find consecutive free seats.</p>

      <p><strong>Alex:</strong> That’s perfect for families or groups.</p>

      <h3>Binary Search — Fast Seat Lookup</h3>

      <p><strong>Jordan:</strong> If seats were indexed and ordered,
        <strong>Binary Search</strong> lets us jump instead of scanning.
      </p>

      <p><strong>Alex:</strong> Divide and conquer — classic.</p>

      <h3>Finding the Gate — BFS</h3>

      <pre><code>found_gate = flight.bfs_nearest_gate("Gate A", "Gate D")
    print("Gate path exists:", found_gate)
    </code></pre>

      <p><strong>Jordan:</strong> BFS explores level by level.</p>

      <p><strong>Alex:</strong> That means it finds the shortest path.</p>

      <h3>Exploring All Routes — DFS</h3>

      <p><strong>Jordan:</strong> If we wanted to explore
        <strong>every possible path</strong> between gates,
        we’d use DFS.
      </p>

      <p><strong>Alex:</strong> Go deep, backtrack, repeat.</p>

      <h3>End of the Simulation</h3>

      <pre><code>print("=== END OF SIMULATION ===")
    </code></pre>

      <p><strong>Alex:</strong> This feels like an actual system now.</p>

      <p><strong>Jordan:</strong> And that’s the point.</p>

      <p><strong>Jordan:</strong> Interviews don’t test algorithms alone —
        they test if you know <strong>when</strong> and
        <strong>why</strong> to use them.
      </p>

      <p><strong>Alex:</strong> So this is LeetCode…
        but with a brain.</p>

      <p><strong>Jordan:</strong> Exactly. Welcome to real programming.</p>

    </section>





  </main>

  <footer>Design by <a href="https://github.com/Junkdog-04" target="_blank" rel="noopener noreferrer">Jorge Rosales</a>
  </footer>

</body>

</html>
